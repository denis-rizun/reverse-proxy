# mini-nginx

---

### Описание проекта

Основная идея проекта заключается в реализации асинхронного reverse proxy‑сервера, который позволяет понимать работу сетевых протоколов и event loop на практике, а также сравнивать две реализации на разных языках.

Проект реализуется на:
- Python (asyncio) — изучение асинхронной работы с TCP, backpressure, таймаутов и потоковой передачи данных.
- Go — низкоуровневая реализация с горутинами, net.Conn, каналами и управлением пулом соединений.

Сервер принимает HTTP/1.1-запросы от клиентов и проксирует их к одному или нескольким upstream‑сервисам, обеспечивая:
- Стриминговую передачу тела запроса и ответа без полного буферизования.
- Балансировку нагрузки между несколькими апстримами (round‑robin).
- Контроль соединений с клиентами и апстримами через лимиты и таймауты.
- Поддержку Keep‑Alive для повторного использования соединений.
- Корректную обработку ошибок, таймаутов и backpressure.
- Минимальное логирование и сбор базовых метрик.

#### Главная цель: не просто получить готовый proxy, а глубоко понять как языки работают с сетью на низком уровне, как управляются сокеты, пайпы, event loop и параллельные задачи.

---

### Запуск проекта

(инструкция будет когда проект будет реализован)

--- 

### Функционал

На данный момент проект реализует:
- Приём TCP-соединений и чтение HTTP/1.1 запросов.
- Стриминговое проксирование запросов и ответов.
- Балансировку между несколькими апстримами (round‑robin).
- Контроль соединений через лимиты на клиентов и upstream.
- Таймауты: connect/read/write/total, настраиваемые через конфигурацию.
- Keep‑Alive соединения с клиентами и апстримами.
- Минимальное логирование запросов, ответов и ошибок.
- Метрики: количество активных соединений, переданных байт, время обработки запроса.

Дополнительно: возможность тестирования обеих реализаций (Python/Go) в одинаковых условиях нагрузки, чтобы сравнить производительность и поведение.

---

### Сущности (предполагаемые)

#### ProxyServer

Отвечает за поднятие TCP‑сервера, принятие клиентских соединений и делегирование их обработчику.

#### ClientConnectionHandler

Читает HTTP-запрос, выбирает upstream, осуществляет двунаправленный стриминг данных и контролирует таймауты и backpressure.

#### UpstreamPool

Хранит список upstream‑сервисов, реализует round‑robin балансировку, управляет лимитом соединений к апстриму и повторным использованием соединений.

#### TimeoutPolicy

Содержит значения таймаутов и обёртки для asyncio.wait_for / context с таймаутами в Go.

#### ConfigLoader

Загружает конфигурацию сервера (YAML/JSON).

#### Logger/Metrics

Логирует события и собирает минимальные метрики: статус ответа, длительность запроса, байты, активные соединения.

---

### Стиль написания

Проект написан с упором на:
- Читаемую, модульную архитектуру.
- Асинхронные best practices: await, drain, cancellation (Python) и управление горутинами (Go).
- Использование принципов SOLID, DRY, KISS.
- Корректную обработку ошибок и завершение соединений без утечек.

---

### Оптимизация
- Стриминговая передача данных без буферизации всего запроса/ответа.
- Backpressure через await writer.drain() (Python) / блокирующее письмо с каналами (Go).
- Контроль числа одновременных соединений и соединений к апстримам для предотвращения перегрузки.

---

### Тестирование
- Локальные upstream-сервисы для проверки проксирования.
- Проверка таймаутов, RPS, latency p95/p99, корректности round‑robin.
- Сравнительный анализ Python vs Go на одинаковых нагрузках, чтобы изучить производительность и поведение низкоуровневых сетевых операций.
